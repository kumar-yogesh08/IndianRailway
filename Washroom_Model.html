<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Railway Washroom Floor Concept</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 8px;
            max-width: 350px;
            border-left: 4px solid #3498db;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 1px; }
        p { font-size: 0.9rem; line-height: 1.4; color: #ddd; margin-bottom: 10px; }
        .controls { margin-top: 15px; display: flex; flex-direction: column; gap: 10px; }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
            text-transform: uppercase;
            font-size: 0.8rem;
        }
        button:hover { background: #2980b9; }
        button.active { background: #27ae60; }
        
        .legend { margin-top: 15px; font-size: 0.8rem; border-top: 1px solid #555; padding-top: 10px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5rem; pointer-events: none;
            transition: opacity 0.5s;
            font-family: monospace;
        }
    </style>
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="loading">Building Washroom Model...</div>

    <div id="ui-container">
        <h1>Smart Washroom Floor</h1>
        <p><strong>Problem:</strong> Water stagnation in train toilets.</p>
        <p><strong>Solution:</strong> A dual-layer floor system. The top layer (Perforated Steel) stays dry. Water falls to the sealed sub-floor, channels to the center, and exits solely via the drainage pipe.</p>
        
        <div class="controls">
            <button id="toggle-water" class="active">Water Flow: ON</button>
            <button id="toggle-top">Toggle Top Floor Visibility</button>
            <button id="toggle-walls">Toggle Walls</button>
            <button id="reset-cam">Reset View</button>
        </div>

        <div class="legend">
            <div class="legend-item"><div class="color-box" style="background:#aaa;"></div>Top: Perforated Steel (Dry)</div>
            <div class="legend-item"><div class="color-box" style="background:#222;"></div>Sub: Sealed Slanted Tray</div>
            <div class="legend-item"><div class="color-box" style="background:#00ffff;"></div>Water Path</div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CONFIG = {
            floorSize: 140,       // cm
            holeRadius: 3.5,      
            holeSpacing: 10,      
            floorThickness: 1.5,    
            subFloorDepth: 15,    // Deeper to allow slope
            slopeAngle: 0.25,     // Slope angle
            waterCount: 700,      // More water
            rainSpeed: 2.0
        };

        let scene, camera, renderer, controls;
        let topFloorMesh, subFloorMesh, wallsGroup, toiletGroup;
        let waterParticles = [];
        let isWaterOn = true;
        let isTopVisible = true;
        let areWallsVisible = true;

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101010);
            scene.fog = new THREE.Fog(0x101010, 100, 600);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 100, 220); // Front-ish view

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // Stay above ground
            controls.target.set(0, -20, 0);

            // 5. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Main overhead light
            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(0, 150, 0);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            scene.add(spotLight);

            const blueLight = new THREE.PointLight(0x3498db, 0.3, 200);
            blueLight.position.set(-50, 50, 50);
            scene.add(blueLight);

            createWashroomEnvironment();
            createFloorSystem();
            initWaterSystem();
            setupEvents();

            document.getElementById('loading').style.opacity = 0;
            animate();
        }

        function createWashroomEnvironment() {
            wallsGroup = new THREE.Group();

            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xeeeeee,
                roughness: 0.2,
                metalness: 0.1
            });

            const floorSize = CONFIG.floorSize;
            // Extend walls deeper to cover the subfloor completely
            const wallHeight = 160; 
            const yOffset = (wallHeight/2) - 40; // Shift down

            // Back Wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(floorSize + 4, wallHeight, 4), wallMaterial);
            backWall.position.set(0, yOffset, -floorSize/2 - 2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            wallsGroup.add(backWall);

            // Front Wall (Transparent/Invisible for viewing but conceptually there)
            // We won't add it to keep view open, but logic assumes it's there.

            // Left Wall
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(4, wallHeight, floorSize), wallMaterial);
            leftWall.position.set(-floorSize/2 - 2, yOffset, 0);
            leftWall.receiveShadow = true;
            wallsGroup.add(leftWall);

            // Right Wall (with opening for pipe)
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(4, wallHeight, floorSize), wallMaterial);
            rightWall.position.set(floorSize/2 + 2, yOffset, 0);
            rightWall.receiveShadow = true;
            wallsGroup.add(rightWall);

            // TOILET MODEL
            toiletGroup = new THREE.Group();
            const steelMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });
            
            const base = new THREE.Mesh(new THREE.CylinderGeometry(15, 20, 30, 32), steelMat);
            base.position.y = 15;
            toiletGroup.add(base);

            const bowl = new THREE.Mesh(new THREE.CylinderGeometry(22, 15, 15, 32), steelMat);
            bowl.position.y = 35;
            toiletGroup.add(bowl);
            
            const tank = new THREE.Mesh(new THREE.BoxGeometry(40, 30, 15), steelMat);
            tank.position.set(0, 50, -25);
            toiletGroup.add(tank);

            toiletGroup.position.set(0, 0, -CONFIG.floorSize/4);
            wallsGroup.add(toiletGroup);

            scene.add(wallsGroup);
        }

        function createFloorSystem() {
            // --- 1. Top Floor (Perforated) ---
            const steelMaterial = new THREE.MeshStandardMaterial({
                color: 0xbbbbbb,
                metalness: 0.6,
                roughness: 0.3,
                side: THREE.DoubleSide
            });

            const shape = new THREE.Shape();
            const s = CONFIG.floorSize / 2;
            shape.moveTo(-s, -s);
            shape.lineTo(s, -s);
            shape.lineTo(s, s);
            shape.lineTo(-s, s);
            shape.lineTo(-s, -s);

            const holeCount = Math.floor(CONFIG.floorSize / CONFIG.holeSpacing);
            const startOffset = -s + (CONFIG.holeSpacing / 2);

            for (let i = 0; i < holeCount; i++) {
                for (let j = 0; j < holeCount; j++) {
                    const hx = startOffset + i * CONFIG.holeSpacing;
                    const hy = startOffset + j * CONFIG.holeSpacing;
                    if (Math.abs(hx) < 25 && hy < -CONFIG.floorSize/4 + 25 && hy > -CONFIG.floorSize/4 - 25) continue;

                    const holePath = new THREE.Path();
                    holePath.absarc(hx, hy, CONFIG.holeRadius, 0, Math.PI * 2, true);
                    shape.holes.push(holePath);
                }
            }

            const extrudeSettings = { steps: 1, depth: CONFIG.floorThickness, bevelEnabled: false };
            const topGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            topGeo.rotateX(Math.PI / 2);
            topGeo.translate(0, -CONFIG.floorThickness, 0);

            topFloorMesh = new THREE.Mesh(topGeo, steelMaterial);
            topFloorMesh.receiveShadow = true;
            topFloorMesh.castShadow = true;
            scene.add(topFloorMesh);

            // --- 2. Sub Floor (Sealed Tray) ---
            const subFloorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            // Make it slightly wider to intersect walls cleanly
            const subGeo = new THREE.BoxGeometry(CONFIG.floorSize + 10, 2, CONFIG.floorSize + 2);
            subFloorMesh = new THREE.Mesh(subGeo, subFloorMat);
            
            subFloorMesh.position.y = -CONFIG.subFloorDepth;
            subFloorMesh.rotation.z = -CONFIG.slopeAngle; 
            
            subFloorMesh.receiveShadow = true;
            scene.add(subFloorMesh);

            // --- 3. Drainage Pipe (Outlet) ---
            const pipeGeo = new THREE.CylinderGeometry(5, 5, 30, 32);
            pipeGeo.rotateZ(Math.PI / 2);
            const pipeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            // Calculate lowest point
            const slopeDrop = (CONFIG.floorSize/2) * Math.tan(CONFIG.slopeAngle);
            const drainY = -CONFIG.subFloorDepth - slopeDrop;
            const drainX = (CONFIG.floorSize/2);

            const drainPipe = new THREE.Mesh(pipeGeo, pipeMat);
            drainPipe.position.set(drainX + 15, drainY + 2, 0); // Stick out of wall
            drainPipe.rotation.z = -0.1;
            
            scene.add(drainPipe);
        }

        function initWaterSystem() {
            const waterGeo = new THREE.SphereGeometry(0.7, 8, 8);
            const waterMat = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff, 
                shininess: 100,
                opacity: 0.9,
                transparent: true
            });

            for(let i=0; i<CONFIG.waterCount; i++) {
                const mesh = new THREE.Mesh(waterGeo, waterMat);
                resetParticle(mesh);
                mesh.userData.active = false; 
                mesh.visible = false;
                setTimeout(() => { mesh.userData.active = true; }, Math.random() * 5000);
                scene.add(mesh);
                waterParticles.push(mesh);
            }
        }

        function resetParticle(mesh) {
            const s = (CONFIG.floorSize / 2) - 5;
            mesh.position.set(
                (Math.random() * s * 2) - s,
                60 + Math.random() * 40, 
                (Math.random() * s * 2) - s
            );
            mesh.visible = false;
            mesh.userData.velocity = new THREE.Vector3(0, -CONFIG.rainSpeed - Math.random(), 0);
            mesh.userData.state = 'falling';
        }

        function updateWater() {
            if(!isWaterOn) return;

            const s = CONFIG.floorSize / 2;
            const slopeTan = Math.tan(CONFIG.slopeAngle);

            waterParticles.forEach(p => {
                if(!p.userData.active) return;
                p.visible = true;

                // Move based on velocity
                p.position.add(p.userData.velocity);

                // --- STATE 1: FALLING ---
                if (p.userData.state === 'falling') {
                    // Check Top Floor
                    if (p.position.y < 0 && p.position.y > -CONFIG.floorThickness) {
                         if (Math.abs(p.position.x) < 20 && p.position.z > -CONFIG.floorSize/4 - 20 && p.position.z < -CONFIG.floorSize/4 + 20) {
                             resetParticle(p); return;
                        }
                        const localX = p.position.x + s;
                        const localZ = p.position.z + s;
                        const remX = Math.abs((localX % CONFIG.holeSpacing) - (CONFIG.holeSpacing/2));
                        const remZ = Math.abs((localZ % CONFIG.holeSpacing) - (CONFIG.holeSpacing/2));
                        const dist = Math.sqrt(remX*remX + remZ*remZ);

                        if (dist < CONFIG.holeRadius) {
                            p.position.x += (Math.random()-0.5)*0.2; // Fall through
                        } else {
                            resetParticle(p); // Hit steel
                        }
                    }

                    // Check Sub Floor
                    const subFloorY = -CONFIG.subFloorDepth - (p.position.x * slopeTan);
                    if (p.position.y <= subFloorY + 1) {
                        p.userData.state = 'sliding';
                        p.position.y = subFloorY + 1;
                        
                        // Initial slide velocity
                        p.userData.velocity.set(1.5, -1.5 * slopeTan, 0); 
                    }
                }

                // --- STATE 2: SLIDING ---
                else if (p.userData.state === 'sliding') {
                    // 1. Funnel Z towards 0 (Center of drain)
                    // The closer to the drain (high X), the stronger the funnel
                    const zDiff = 0 - p.position.z;
                    p.position.z += zDiff * 0.05; // Gentle steer towards center

                    // 2. Increase X (Down slope)
                    p.position.x += 1.5; 

                    // 3. Maintain Y on slope
                    const subFloorY = -CONFIG.subFloorDepth - (p.position.x * slopeTan);
                    p.position.y = subFloorY + 1;

                    // 4. Hit Wall logic (Right side wall)
                    if (p.position.x > s) {
                        p.position.x = s; // Clamp to wall
                        
                        // If near center (Pipe hole radius approx 8 units)
                        if (Math.abs(p.position.z) < 8) {
                            p.userData.state = 'draining';
                            p.userData.velocity.set(3.0, -0.5, 0); // Shoot out
                        } else {
                            // Gutter effect: Slide along the wall towards Z=0
                            const zDir = p.position.z > 0 ? -1 : 1;
                            p.position.z += zDir * 2.0; // Fast slide to center
                            
                            // Visual constraint
                            p.position.y = subFloorY + 1; // Stay on floor level
                        }
                    }
                }

                // --- STATE 3: DRAINING ---
                else if (p.userData.state === 'draining') {
                    p.userData.velocity.y -= 0.1; // Gravity
                }

                // Reset
                if (p.position.y < -100) {
                    resetParticle(p);
                }
            });
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('toggle-top').addEventListener('click', (e) => {
                isTopVisible = !isTopVisible;
                topFloorMesh.visible = isTopVisible;
                e.target.innerText = isTopVisible ? "Hide Top Floor" : "Show Top Floor";
            });

            document.getElementById('toggle-walls').addEventListener('click', (e) => {
                areWallsVisible = !areWallsVisible;
                wallsGroup.visible = areWallsVisible;
            });

            document.getElementById('toggle-water').addEventListener('click', (e) => {
                isWaterOn = !isWaterOn;
                e.target.classList.toggle('active');
                e.target.innerText = isWaterOn ? "Water Flow: ON" : "Water Flow: PAUSED";
                if(!isWaterOn) waterParticles.forEach(p => p.visible = false);
            });

            document.getElementById('reset-cam').addEventListener('click', () => {
                controls.reset();
                camera.position.set(0, 100, 220);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateWater();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>